\scnheader{Реализация scl-машины}
\scnidtf{Программный вариант реализации машины логического вывода scl}
\scnidtf{Машина логического вывода scl}
\scnidtf{scl-машина}
\scnidtf{scl-machine}
\scnidtf{ostis-inference}
\scniselement{машина обработки знаний}
\scnrelto{программная модель}{Абстрактная scl-машина}
\scnrelfrom{внутренний язык}{Язык SCL}
\begin{scnrelfromset}{декомпозиция программной системы}
    \scnitem{База знаний scl-machine}
    \scnitem{Решатель задач scl-machine}
    \scnitem{Интерфейс scl-machine}
\end{scnrelfromset}

\scnheader{Решатель задач scl-machine}
\begin{scnrelfromset}{обобщённая декомпозиция}
    \scnitem{Агент прямого логического вывода}
    \scnitem{Агент обратного логического вывода}
    \begin{scnindent}
        \scntext{примечание}{Не реализовано.}
    \end{scnindent}
    \scnitem{Агент применения правил вывода}
    \begin{scnindent}
        \scntext{примечание}{Не реализовано.}
    \end{scnindent}
    \scnitem{Агент эквивалентных преобразований логической формулы}
    \begin{scnindent}
        \scntext{примечание}{Не реализовано.}
    \end{scnindent}
    \scnitem{Агент удаления дерева решения}
\end{scnrelfromset}
\begin{scnrelfromset}{реализованные логические связки}
    \scnitem{импликация*}
    \scnitem{дизъюнкция*}
    \scnitem{конъюнкция*}
    \scnitem{отрицание*}
\end{scnrelfromset}
\begin{scnrelfromset}{не реализованные логические связки}
    \scnitem{эквиваленция*}
    \scnitem{строгая дизъюнкция*}
\end{scnrelfromset}

\scnheader{менеджер логического вывода}
\scnidtf{InferenceManagerAbstract}
\scntext{примечание}{менеджер логического вывода определяет, каким образом производится обход и применение логических формул.}
\scnrelfrom{программный интерфейс}{Программный интерфейс менеджера логического вывода}
\begin{scnrelfromset}{обязательные понятия для спецификации заданной сущности}
    \scnitem{искатель атомарных логических формул}
    \begin{scnindent}
        \scnidtf{TemplateSearcherAbstract}
    \end{scnindent}
    \scnitem{менеджер обработки атомарных логических формул}
    \begin{scnindent}
        \scnidtf{TemplateManagerAbstract}
    \end{scnindent}
    \scnitem{менеджер дерева решений}
    \begin{scnindent}
        \scnidtf{SolutionTreeManagerAbstract}
    \end{scnindent}
\end{scnrelfromset}
\begin{scnrelfromset}{декомпозиция}
    \scnitem{менеджер прямого логического вывода по цели}
    \begin{scnindent}
        \scnidtf{DirectInferenceManagerTarget}
    \end{scnindent}
    \scnitem{менеджер прямого логического вывода по всем логических формулам}
    \begin{scnindent}
        \scnidtf{DirectInferenceManagerAll}
    \end{scnindent}
\end{scnrelfromset}

\scnheader{Программный интерфейс менеджера логического вывода}
\scnhaselement{Метод применения логического вывода}
\begin{scnindent}
    \scntext{заголовок метода}{virtual bool ApplyInference(InferenceParamsConfig const \& inferenceParamsConfig) = 0;}
    \scntext{примечание}{Главный метод менеджера логического вывода, который определяет порядок обхода и формул.}
\end{scnindent}
\scnhaselement{Метод применения логической формулы}
\begin{scnindent}
    \scntext{заголовок метода}{LogicFormulaResult UseFormula(ScAddr const \& formula, ScAddr const \& outputStructure);}
    \scntext{примечание}{Метод менеджера логического вывода, который анализирует логическую формулу и генерирует атомарные логические формулы по импликации.}
\end{scnindent}

\scnheader{искатель атомарных логических формул}
\scnrelfrom{программный интерфейс}{Программный интерфейс искателя атомарных логических формул}
\begin{scnindent}
    \begin{scneqtoset}
        \scnitem{метод поиска атомарных логических формул по параметрам}
        \begin{scnindent}
            \scntext{заголовок метода}{virtual void searchTemplate(ScAddr const \& templateAddr, ScTemplateParams const
            \& templateParams, ScAddrUnorderedSet const \& variables, Replacements \& result) = 0;}
            \scntext{примечание}{Метод ищет конструкции в базе знаний по графу-образцу (логической атомарной формулы)
                с учётом переданных параметров графа-образца и создаёт соответствие между sc-переменными формулы и
                соответствующими ей константными sc-элементами.}
        \end{scnindent}
        \scnitem{метод поиска атомарных логических формул по множеству параметров}
        \begin{scnindent}
            \scntext{заголовок метода}{virtual void searchTemplate(
                ScAddr const \& templateAddr,
                vector<ScTemplateParams> const \& scTemplateParamsVector,
                ScAddrUnorderedSet const \& variables,
                Replacements \& result);}
            \scntext{примечание}{Метод вызывает \scnkeyword{метод поиска атомарных логических формул по параметрам} в цикле для переданного множества параметров поиска.}
        \end{scnindent}
    \end{scneqtoset}
\end{scnindent}
\begin{scnrelfromset}{декомпозиция}
    \scnitem{искатель атомарных логических формул по всей базе знаний}
    \begin{scnindent}
        \scnidtf{TemplateSearcherGeneral}
        \scntext{примечание}{Поиск конструкций осуществляется по всей базе знаний.}
    \end{scnindent}
    \scnitem{искатель атомарных логических формул в структурах}
    \begin{scnindent}
        \scnidtf{TemplateSearcherInStructures}
        \scntext{примечание}{Все найденные конструкции должны принадлежать любой структуре из множества входных структур.}
    \end{scnindent}
    \scnitem{искатель атомарных логических формул в структурах, проверяющий только дуги принадлежности}
    \begin{scnindent}
	    \scnidtf{TemplateSearcherOnlyMembershipArcsInStructures}
	    \scntext{примечание}{Все дуги принадлежности у найденных конструкций должны принадлежать любой структуре из множества входных структур.}
    \end{scnindent}
\end{scnrelfromset}

\scnheader{менеджер обработки атомарных логических формул}
\scnrelfrom{программный интерфейс}{Программный интерфейс менеджера обработки атомарных логических формул}
\begin{scnindent}
    \begin{scneqtoset}
        \scnitem{метод создания параметров поиска атомарной логической формулы}
        \begin{scnindent}
            \scntext{заголовок метода}{virtual std::vector<ScTemplateParams> CreateTemplateParams(ScAddr const \& scTemplate) = 0;}
            \scntext{примечание}{Метод формирует множество параметров атомарной логической формулы.}
        \end{scnindent}
    \end{scneqtoset}
\end{scnindent}
\begin{scnrelfromset}{декомпозиция}
    \scnitem{менеджер обработки атомарных логических формул}
    \begin{scnindent}
        \scnidtf{TemplateManager}
        \scntext{примечание}{Формирование параметров осуществляется по всей базе знаний. Происходит поиск переменных
        sc-узлов в атомарной логической формулы с их классами и формируется соответствие их с константными sc-узлами с такими же классами в базе знаний.}
    \end{scnindent}
    \scnitem{менеджер обработки атомарных логических формул с фиксированными аргументами}
    \begin{scnindent}
        \scnidtf{TemplateManagerFixedArguments}
        \scntext{примечание}{Формирование параметров осуществляется по переданным аргументами и спецификации формулы.
        Переменная, формуле под первой ролью, соответствует первому аргументу из множества аргументов логического вывода.}
    \end{scnindent}
\end{scnrelfromset}

\scnheader{менеджер дерева решений}
\scnrelfrom{программный интерфейс}{Программный интерфейс менеджера дерева решений}
\begin{scnindent}
    \begin{scneqtoset}
        \scnitem{метод создания узла дерева решения}
        \begin{scnindent}
            \scntext{заголовок метода}{virtual bool AddNode(ScAddr const \& formula, Replacements const \& replacements) = 0;}
            \scntext{примечание}{Данный метод определяет структуру и создание узлов дерева решения.}
        \end{scnindent}
    \end{scneqtoset}
\end{scnindent}
\begin{scnrelfromset}{декомпозиция}
    \scnitem{менеджер дерева решений с подстановками}
    \begin{scnindent}
        \scnidtf{SolutionTreeManager}
        \scntext{примечание}{Узел такого дерева решения состоит из применённой логической формулы и соответствий sc-переменных sc-константам, которые были использованы в атомарных формулах.}
    \end{scnindent}
    \scnitem{пустой менеджер дерева решений}
    \begin{scnindent}
        \scnidtf{SolutionTreeManagerEmpty}
        \scntext{примечание}{В такой реализации менеджера дерева решений узлы не создаются. Такая реализация сделана из соображений оптимизации.}
    \end{scnindent}
\end{scnrelfromset}

\scnheader{конфиг менеджера логического вывода}
\scnidtf{InferenceFlowConfig}
\scntext{примечание}{Такой конфиг используется при создании менеджера логического вывода.}
\scnhaselement{generationType}
\begin{scnindent}
    \scntext{примечание}{Определяет, нужно ли генерировать уже существующие конструкции в базе знаний.
    От этого зависит, нужно ли перед генерацией атомарной логической формулы искать её в базе знаний.
    Если не искать, это даёт большой прирост в производительности логического вывода.}
\end{scnindent}
\scnhaselement{replacementsUsingType}
\begin{scnindent}
    \scntext{примечание}{Определяет, нужно ли прерывать генерацию атомарной логической формулы по множеству аргументов после первой успешной генерации.}
\end{scnindent}
\scnhaselement{solutionTreeType}
\begin{scnindent}
    \scntext{примечание}{Определяет, нужно ли создавать узлы в дереве решений.
    Если не нужно, то в процессе логического вывода используется \scnkeyword{пустой менеджер дерева решений}.}
\end{scnindent}
\scnhaselement{searchType}
\begin{scnindent}
	\scntext{примечание}{Определяет, какой \scnkeyword{искатель атомарных логических формул} нужно использовать для поиска подстановок, на которых атомарная логическая формула истина.}
\end{scnindent}
\scnhaselement{outputStructureFillingType}
\begin{scnindent}
	\scntext{примечание}{Определяет, какие конструкции добавляются в выходную структуру(только сгенерированные или найденные и сгенерированные).}
\end{scnindent}
\scnhaselement{atomicLogicalFormulaSearchBeforeGenerationType}
\begin{scnindent}
	\scntext{примечание}{Определяет, нужно ли перед всеми генерациями атомарной логической формулы делать только один поиск по базе знаний на пустых подстановках, или перед каждой генерацией делать поиск, используя ScTemplateParams. Влияет только на производительность, например в базе знаний нашлось 100,000 посылок импликации и вместо того, чтоб использовать поиск по шаблону 100,000 раз для проверки существования каждого заключения, выполняется только один поиск по шаблону для нахождения всех существующих заключений, и, используя полученные результаты, генерация вызывается только для тех подстановок посылки, для которых не нашлись соответствующие заключения. Предварительный поиск на пустых подстановках имеет смысл использовать тогда, когда генерация атомарной логической формулы не прерывается после первой успешной генерации, перед генерацией проверяется существование генерируемой атомарной логической формулы в базе знаний и в базе знаний находится много конструкций, удовлетворяющих шаблону генерируемой атомарнй логической формулы.}
\end{scnindent}

\scnheader{соответствие между множеством sc-переменных, входящих в логическую формулу, и множеством кортежей sc-констант}
\scnidtf{Replacements}
\scnidtf{подстановки}
\scntext{примечание}{Является взаимно однозначным соответствием между множеством sc-переменных и множеством кортежей sc-констант. Областью отправления соответствия является множество всех sc-переменных атомарной логической формулы, а соответствующим определённой sc-переменной элементом из области прибытия соответствия является кортеж, элементы которого при подстановке их в атомарную логическую формулу на место этой sc-переменнной делают формулу истинной. Корректно составленные подстановки имеют равномощные множества в области прибытия. Таким образом, элементы области прибытия могут образовывать прямоугольную матрицу. В этой матрице по колонкам для каждой переменной хранятся подстановки, при замене каждой sc-переменной на которую атомарная логическая формула становится истинной.}
\scntext{тип}{std::unordered\_map<ScAddr, ScAddrVector, ScAddrHashFunc<uint32\_t$\gg$;}
\scnhaselement{
	\begin{adjustwidth}{\calctab}{0em}
		\setlength{\parindent}{0em}
		\setlength{\itemindent}{0em}
		\setlength{\parskip}{0em}
		\rowcolors{1}{white}{white}
		\begin{tabular}{lllllll}
			\{\textless{} & \_e1 & ,\textless{} & e1 & , & e2 & \textgreater{}\textgreater{},  \\
			\textless{} & \_v1 & ,\textless{} & n1 & , & n2 & \textgreater{}\textgreater{},  \\
			\textless{} & \_e2 & ,\textless{} & e3 & , & e4 & \textgreater{}\textgreater{},  \\
			\textless{} & \_v2 & ,\textless{} & n3 & , & n3 & \textgreater{}\textgreater{}\}
		\end{tabular}
	\end{adjustwidth}
}
\begin{scnindent}
	\scnrelfrom{комментарий}{Если в формулу example\_formula на место переменных \_e1, \_v1, \_e2, \_v2 подставить первую колонку области прибытия подстановок e1, n1, e3, n3 соответственно, то атомарная логическая формула example\_formula станет истинной. То же самое можно сказать и со значениями второй колонки.}
	\scnrelfrom{описание примера}{\scnfileimage[40em]{images/replacements_example.png}}
\end{scnindent}

\scnheader{объект создания менеджера логического вывода}
\scnidtf{InferenceManagerFactory}
\scnidtf{фабрика менеджера логического вывода}
\scntext{примечание}{С помощью него создаётся менеджер логического вывода в соответствии с переданным \scnkeyword{Конфигом процесса логического вывода}.}

\scnheader{Агент прямого логического вывода}
\scnidtf{sc-агент прямого логического вывода}
\scntext{примечание}{Задачей sc-агента прямого логического вывода является генерация новых знаний
на основе некоторых логических утверждений. Данный sc-агент активируется при появлении в sc-памяти инициированного действия,
принадлежащего классу \textit{действие прямого логического вывода}. После проверки sc-агентом условия инициирования
выполняется процесс прямого логического вывода.}
\scnrelfrom{пример входной конструкции}{\scnfileimage[20em]{images/direct_inference_input.png}}
\begin{scnrelfromvector}{аргументы агента}
    \scnitem{\_target\_template}
    \begin{scnindent}
        \scnidtf{targetTemplate}
        \scnidtf{targetStatement}
        \scnidtf{шаблон цели}
        \scnidtf{ожидаемый результат выполнения логического вывода}
        \scntext{пояснение}{Шаблон, успешный поиск которого показывает, что цель логического вывода достигнута и применение правил можно прекратить.}
        \scnrelfrom{описание примера}{\scnfileimage[28em]{images/target_template.png}}
    \end{scnindent}
    \scnitem{\_formulas\_set}
    \begin{scnindent}
        \scnidtf{formulasSet}
        \scntext{пояснение}{Ориентированное множество множеств формул, применяя которые требуется совершить логический вывод.
        Первым элементом множества является множество формул, которые применяются в первую очередь, а каждое следующее
        множество формул применяется после предыдущего. Таким образом указываются приоритеты множеств формул.}
        \scnrelfrom{описание примера}{\scnfileimage[27em]{images/formulas_set.png}}
        \scnrelfrom{описание примера}{\scnfileimage[37em]{images/formula_example.png}}
    \end{scnindent}
    \scnitem{arguments}
    \begin{scnindent}
        \scntext{пояснение}{Множество, элементы которого используются при применении правил. Каждый sc-узел этого множества
        подставляется как значение переменных атомарных логических формул (в том числе шаблона цели).}
        \begin{scnindent}
            \scntext{примечание}{Можно использовать структуру всей базы знаний системы, например, sc-узел \scnkeyword{База знаний IMS}.}
        \end{scnindent}
        \scnrelfrom{описание примера}{\scnfileimage[27em]{images/arguments.png}}
    \end{scnindent}
    \scnitem{\_intput\_structure}
    \begin{scnindent}
        \scntext{пояснение}{Структура, в которой происходит поиск при проверке истинности атомарных логических формул.}
    \end{scnindent}
\end{scnrelfromvector}
\scnrelfrom{ответ агента}{ответ агента прямого логического вывода}
\begin{scnindent}
    \scntext{примечание}{В результате выполнения агентом логического вывода действия, в sc-памяти формируется sc-структура,
        представляющая собой дерево решения. Это дерево состоит из последовательности пар, в которых первым элементом
        является применённое правило, а вторым - множество пар подстановок и переменных, соединённых временной дугой
        принадлежности, выходящей из переменного узла, при которых данное правило выполняется. Такое дерево может быть пустым
        в случае, если требуемую структуру не удалось сгенерировать в ходе логического вывода. При достижении цели вывода
        узел дерева решения позитивно принадлежит классу concept\_success\_solution, при недостижении -- негативно.
        Корень этого дерева находится в связке под отношением nrel\_output\_structure со структурой, в которую
        добавляются сгенерированные в ходе логического вывода конструкции.}
    \scnrelfrom{описание примера}{\scnfileimage[35em]{images/direct_inference_output.png}}
\end{scnindent}
\scntext{примечание}{Работа агента заключается в последовательном применении правил из входного множества правил,
    генерируя структуры, если атомарная формула принадлежит классу формул для генерации (\scnkeyword{concept\_formula\_for\_generation}).
    Если правило применилось безуспешно, то оно добавляется во множество безуспешно применённых
    правил, которые применяются повторно в случае успешного применения какого-либо другого правила. Также после
    каждого успешного применения правила проверяется, достигнута ли цель (если она передана), и, если цель достигнута,
    выполнение агента завершается успешно и остальные правила не применяются.}
\begin{scnrelfromvector}{обобщённый алгоритм}
    \scnfileitem{Получение параметров агента, вызов агента;}
    \scnfileitem{Получение всех sc-узлов из arguments, если множество валидно, заполнение ими списка аргументов;}
    \scnfileitem{Проверка, достигнута ли уже цель в базе знаний с полученными аргументами;}
    \begin{scnindent}
        \scntext{примечание}{Выполняется поиск по шаблону target template с параметрами arguments.
        Если шаблон найден, агент завершает работу, возвращает узел, принадлежащий \scnkeyword{concept\_success\_solution}.}
    \end{scnindent}
    \scnfileitem{Построение вектора очереди формул на основе множества формул. Цикл по всем правилам и пока не достигнута цель;}
    \begin{scnindent}
        \begin{scnrelfromvector}{циклические операции}
            \scnfileitem{Получение посылки логической формулы;}
            \scnfileitem{Определение типа посылки (связка конъюнкции, дизъюнкции, отрицания или атомарная логическая формула);}
            \scnfileitem{Проверка истинности посылки в зависимости от её типа;}
            \begin{scnindent}
                \scntext{замечание}{Конъюнкция, дизъюнкция, отрицание работают нестабильно.}
            \end{scnindent}
            \scnfileitem{Генерация по шаблону следствия;}
            \scnfileitem{Добавление в дерево решений узла формулы.}
            \begin{scnindent}
                \scntext{примечание}{Смотрите пример ответа агента.}
            \end{scnindent}
        \end{scnrelfromvector}
    \end{scnindent}
    \scnfileitem{Формирование дерева применённых формул.}
\end{scnrelfromvector}


\begin{scnrelfromset}{недостатки текущего состояния}
    \scnfileitem{В текущем состоянии не реализован механизм применения правил вывода, вместо него указываются формулы
    для генерации, используя класс \scnkeyword{concept\_formula\_for\_generation}.}
    \scnfileitem{Генерируются только атомарные формулы.}
    \scnfileitem{Логическая связка отрицания некорректно работает с подстановками.}
    \scnfileitem{В структуру ответа агента входит только узел solution, а не вся структура решения.}
\end{scnrelfromset}

\begin{scnrelfromset}{преимущества текущего состояния}
    \scnfileitem{Агент работает корректно при передаче параметров в соответствии с предыдущим вариантом его реализации.}
    \scnfileitem{Проверка входных параметров не только по невалидности sc-узла, но и проверка на непустое множество.}
\end{scnrelfromset}

\scnheader{Агент удаления дерева решения}
\scntext{примечание}{Задачей sc-агента удаления дерева решения является удаление из sc-памяти элементов, образующих дерево решения. Данный sc-агент активируется при появлении в sc-памяти инициированного действия,
	принадлежащего классу \textit{действие. удалить решение}. После проверки sc-агентом условия инициирования
	выполняется удаление дерева решения.}
\scnrelfrom{пример входной конструкции}{\scnfileimage[45em]{images/erase_solution_tree_input.png}}
\begin{scnrelfromvector}{аргументы агента}
	\scnitem{\_solution\_tree}
	\begin{scnindent}
		\scnidtf{solutionTree}
		\scnidtf{solution}
		\scntext{пояснение}{Дерево решения, которое требуется удалить.}
	\end{scnindent}
\end{scnrelfromvector}
\scnrelfrom{ответ агента}{ответ агента удаления дерева решения}
\begin{scnindent}
	\scntext{примечание}{В результате выполнения агентом удаления дерева решения действия, из sc-памяти дерево со всеми его элементами, кроме самих переменных и их подстановок.}
	\scnrelfrom{описание примера}{\scnfileimage[35em]{images/erase_solution_tree_output.png}}
\end{scnindent}
\scntext{примечание}{Работа агента заключается в обходе дерева с удалением связок, обозначающих пары правила со множеством подстановок, на которых это правило применилось, множества подстановок, на которых это правило применилось, связок, обозначающих пары переменных с их значениями, и временных дуг принадлежностей между переменными и их значениями.}
