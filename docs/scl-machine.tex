\scnheader{Реализация scl-машины}
\scnidtf{Программный вариант реализации машины логического вывода scl}
\scnidtf{Машина логического вывода scl}
\scnidtf{scl-машина}
\scnidtf{scl-machine}
\scnidtf{ostis-inference}
\scniselement{машина обработки знаний}
\scnrelto{программная модель}{Абстрактная scl-машина}
\scnrelfrom{внутренний язык}{Язык SCL}
\begin{scnrelfromset}{декомпозиция программной системы}
    \scnitem{База знаний scl-machine}
    \scnitem{Решатель задач scl-machine}
    \scnitem{Интерфейс scl-machine}
\end{scnrelfromset}

\scnheader{Решатель задач scl-machine}
\begin{scnrelfromset}{обобщённая декомпозиция}
    \scnitem{Агент прямого логического вывода}
    \scnitem{Агент обратного логического вывода}
    \begin{scnindent}
        \scntext{примечание}{Не реализовано.}
    \end{scnindent}
    \scnitem{Агент применения правил вывода}
    \begin{scnindent}
        \scntext{примечание}{Не реализовано.}
    \end{scnindent}
    \scnitem{Агент эквивалентных преобразований логической формулы}
    \begin{scnindent}
        \scntext{примечание}{Не реализовано.}
    \end{scnindent}
    \begin{scnrelfromset}{реализованные логические связки}
        \scnitem{импликация*}
        \scnitem{дизъюнкция*}
        \scnitem{конъюнкция*}
        \scnitem{отрицание*}
    \end{scnrelfromset}
    \begin{scnrelfromset}{не реализованные логические связки}
        \scnitem{эквиваленция*}
        \scnitem{строгая дизъюнкция*}
    \end{scnrelfromset}
\end{scnrelfromset}

\scnheader{менеджер логического вывода}
\scnidtf{InferenceManagerAbstract}
\scntext{примечание}{менеджер логического вывода определяет, каким образом производиться обход и применение логических формул.}
\scnrelfrom{программный интерфейс}{Программный интерфейс менеджера логического вывода}
\begin{scnrelfromset}{обязательные понятия для спецификации заданной сущности}
    \scnitem{искатель атомарных логических формул}
    \begin{scnindent}
        \scnidtf{TemplateSearcherAbstract}
    \end{scnindent}
    \scnitem{менеджер обработки атомарных логических формул}
    \begin{scnindent}
        \scnidtf{TemplateManagerAbstract}
    \end{scnindent}
    \scnitem{менеджер дерева решений}
    \begin{scnindent}
        \scnidtf{SolutionTreeManagerAbstract}
    \end{scnindent}
\end{scnrelfromset}
\begin{scnrelfromset}{декомпозиция}
    \scnitem{менеджер прямого логического вывода по цели}
    \begin{scnindent}
        \scnidtf{DirectInferenceManagerTarget}
    \end{scnindent}
    \scnitem{менеджер прямого логического вывода по всем логических формулам}
    \begin{scnindent}
        \scnidtf{DirectInferenceManagerAll}
    \end{scnindent}
\end{scnrelfromset}

\scnheader{Программный интерфейс менеджера логического вывода}
\scnhaselement{Метод применения логического вывода}
\begin{scnindent}
    \scntext{заголовок метода}{virtual bool applyInference(InferenceParamsConfig const \& inferenceParamsConfig) = 0;}
    \scntext{примечание}{Главный метод менеджера логического вывода, который определяет порядок обхода и формул.}
\end{scnindent}
\scnhaselement{Метод применения логической формулы}
\begin{scnindent}
    \scntext{заголовок метода}{LogicFormulaResult useFormula(ScAddr const \& formula, ScAddr const \& outputStructure);}
    \scntext{примечание}{Метод менеджера логического вывода, который анализирует логическую формулу и генерирует атомарные логические формулы по импликации.}
\end{scnindent}

\scnheader{искатель атомарных логических формул}
\scnrelfrom{программный интерфейс}{Программный интерфейс искателя атомарных логических формул}
\begin{scnindent}
    \begin{scneqtoset}
        \scnitem{метод поиска атомарных логических формул по параметрам}
        \begin{scnindent}
            \scntext{заголовок метода}{virtual void searchTemplate(ScAddr const \& templateAddr, ScTemplateParams const
            \& templateParams, std::set<std::string> const \& varNames, Replacements \& result) = 0;}
            \scntext{примечание}{Метод ищет конструкции в базе знаний по графу-образцу (логической атомарной формулы)
                с учётом переданных параметров графа-образца и создаёт соответствие между sc-переменными формулы и
                соответствующими ей константными sc-элементами.}
        \end{scnindent}
        \scnitem{метод поиска атомарных логических формул по множеству параметров}
        \begin{scnindent}
            \scntext{заголовок метода}{virtual void searchTemplate(
                ScAddr const \& templateAddr,
                vector<ScTemplateParams> const \& scTemplateParamsVector,
                std::set<std::string> const \& varNames,
                Replacements \& result);}
            \scntext{примечание}{Метод вызывает \scnkeyword{метод поиска атомарных логических формул по параметрам} в цикле для переданного множества параметров поиска.}
        \end{scnindent}
    \end{scneqtoset}
\end{scnindent}
\begin{scnrelfromset}{декомпозиция}
    \scnitem{искатель атомарных логических формул по всей базе знаний}
    \begin{scnindent}
        \scnidtf{TemplateSearcher}
        \scntext{примечание}{Поиск конструкций осуществляется по всей базе знаний.}
    \end{scnindent}
    \scnitem{искатель атомарных логических формул в структурах}
    \begin{scnindent}
        \scnidtf{TemplateSearcherInStructures}
        \scntext{примечание}{Все найденные конструкции должны принадлежать любой структуре из множества входных структур.}
    \end{scnindent}
\end{scnrelfromset}

\scnheader{менеджер обработки атомарных логических формул}
\scnrelfrom{программный интерфейс}{Программный интерфейс менеджера обработки атомарных логических формул}
\begin{scnindent}
    \begin{scneqtoset}
        \scnitem{метод создания параметров поиска атомарной логической формулы}
        \begin{scnindent}
            \scntext{заголовок метода}{virtual std::vector<ScTemplateParams> createTemplateParams(ScAddr const \& scTemplate) = 0;}
            \scntext{примечание}{Метод формирует множество параметров атомарной логической формулы.}
        \end{scnindent}
    \end{scneqtoset}
\end{scnindent}
\begin{scnrelfromset}{декомпозиция}
    \scnitem{менеджер обработки атомарных логических формул}
    \begin{scnindent}
        \scnidtf{TemplateManager}
        \scntext{примечание}{Формирование параметров осуществляется по всей базе знаний. Происходит поиск переменных
        sc-узлов в атомарной логической формулы с их классами и формируется соответствие их с константными sc-узлами с такими же классами в базе знаний.}
    \end{scnindent}
    \scnitem{менеджер обработки атомарных логических формул с фиксированными аргументами}
    \begin{scnindent}
        \scnidtf{TemplateManagerFixedArguments}
        \scntext{примечание}{Формирование параметров осуществляется по переданным аргументами и спецификации формулы.
        Переменная, формуле под первой ролью, соответствует первому аргументу из множества аргументов логического вывода.}
    \end{scnindent}
\end{scnrelfromset}

\scnheader{менеджер дерева решений}
\scnrelfrom{программный интерфейс}{Программный интерфейс менеджера дерева решений}
\begin{scnindent}
    \begin{scneqtoset}
        \scnitem{метод создания узла дерева решения}
        \begin{scnindent}
            \scntext{заголовок метода}{virtual bool addNode(ScAddr const \& formula, Replacements const \& replacements) = 0;}
            \scntext{примечание}{Данный метод определяет структуру и создание узлов дерева решения.}
        \end{scnindent}
    \end{scneqtoset}
\end{scnindent}
\begin{scnrelfromset}{декомпозиция}
    \scnitem{менеджер дерева решений с подстановками}
    \begin{scnindent}
        \scnidtf{SolutionTreeManager}
        \scntext{примечание}{Узел такого дерева решения состоит из применённой логической формулы и соответствий sc-переменных sc-константам, которые были использованы в атомарных формулах.}
    \end{scnindent}
    \scnitem{пустой менеджер дерева решений}
    \begin{scnindent}
        \scnidtf{SolutionTreeManagerEmpty}
        \scntext{примечание}{В такой реализации менеджера дерева решений узлы не создаются. Такая реализация сделана из соображений оптимизации.}
    \end{scnindent}
\end{scnrelfromset}

\scnheader{конфиг менеджера логического вывода}
\scnidtf{InferenceFlowConfig}
\scntext{примечание}{Такой конфиг используется при создании менеджера логического вывода.}
\scnhaselement{generationType}
\begin{scnindent}
    \scntext{примечание}{Определяет, нужно ли генерировать уже существующие конструкции в базе знаний.
    От этого зависит, нужно ли перед генерацией атомарной логической формулы искать её в базе знаний.
    Если не искать, это даёт большой прирост в производительности логического вывода.}
\end{scnindent}
\scnhaselement{replacementsUsingType}
\begin{scnindent}
    \scntext{примечание}{Определяет, нужно ли прерывать генерацию атомарной логической формулы по множеству аргументов после первой успешной генерации.}
\end{scnindent}
\scnhaselement{solutionTreeType}
\begin{scnindent}
    \scntext{примечание}{Определяет, нужно ли создавать узлы в дереве решений.
    Если не нужно, то в процессе логического вывода используется \scnkeyword{пустой менеджер дерева решений}.}
\end{scnindent}

\scnheader{объект создания менеджера логического вывода}
\scnidtf{InferenceManagerFactory}
\scnidtf{фабрика менеджера логического вывода}
\scntext{примечание}{С помощью него создаётся менеджер логического вывода в соответствии с переданным \scnkeyword{Конфигом процесса логического вывода}.}

\scnheader{Агент прямого логического вывода}
\scnidtf{sc-агент прямого логического вывода}
\scntext{примечание}{Задачей sc-агента прямого логического вывода является генерация новых знаний
на основе некоторых логических утверждений. Данный sc-агент активируется при появлении в sc-памяти инициированного действия,
принадлежащего классу \textit{действие прямого логического вывода}. После проверки sc-агентом условия инициирования
выполняется процесс прямого логического вывода.}
\begin{scnindent}
    \scnrelfrom{пример входной конструкции}{\scnfileimage[20em]{images/direct_inference_input.png}}
    \begin{scnrelfromvector}{аргументы агента}
        \scnitem{\_target\_template}
        \begin{scnindent}
            \scnidtf{targetTemplate}
            \scnidtf{targetStatement}
            \scnidtf{шаблон цели}
            \scnidtf{ожидаемый результат выполнения логического вывода}
            \scntext{пояснение}{Шаблон, успешный поиск которого показывает, что цель логического вывода достигнута и применение правил можно прекратить.}
            \scnrelfrom{описание примера}{\scnfileimage[28em]{images/target_template.png}}
        \end{scnindent}
        \scnitem{\_formulas\_set}
        \begin{scnindent}
            \scnidtf{formulasSet}
            \scntext{пояснение}{Ориентированное множество множеств формул, применяя которые требуется совершить логический вывод.
            Первым элементом множества является множество формул, которые применяются в первую очередь, а каждое следующее
            множество формул применяется после предыдущего. Таким образом указываются приоритеты множеств формул.}
            \scnrelfrom{описание примера}{\scnfileimage[27em]{images/formulas_set.png}}
            \begin{scnindent}
                \scnrelfrom{описание примера}{\scnfileimage[37em]{images/formula_example.png}}
            \end{scnindent}
        \end{scnindent}
        \scnitem{arguments}
        \begin{scnindent}
            \scntext{пояснение}{Множество, элементы которого используются при применении правил. Каждый sc-узел этого множества
            подставляется как значение переменных атомарных логических формул (в том числе шаблона цели).}
            \begin{scnindent}
                \scntext{примечание}{Можно использовать структуру всей базы знаний системы, например, sc-узел \scnkeyword{База знаний IMS}.}
            \end{scnindent}
            \scnrelfrom{описание примера}{\scnfileimage[27em]{images/arguments.png}}
        \end{scnindent}
        \scnitem{\_intput\_structure}
        \begin{scnindent}
            \scntext{пояснение}{Структура, в которой происходит поиск при проверке истинности атомарных логических формул.}
        \end{scnindent}
    \end{scnrelfromvector}
    \scnrelfrom{ответ агента}{ответ агента прямого логического выода}
    \begin{scnindent}
        \scntext{примечание}{В результате выполнения агентом логического вывода действия, в sc-памяти формируется sc-структура,
            представляющая собой дерево решения. Это дерево состоит из последовательности пар, в которых первым элементом
            является применённое правило, а вторым - множество пар подстановок и переменных, соединённых временной дугой
            принадлежности, выходящей из переменного узла, при которых данное правило выполняется. Такое дерево может быть пустым
            в случае, если требуемую структуру не удалось сгенерировать в ходе логического вывода. При достижении цели вывода
            узел дерева решения позитивно принадлежит классу concept\_success\_solution, при недостижении -- негативно.
            Корень этого дерева находится в связке под отношением nrel\_output\_structure со структурой, в которую
            добавляются сгенерированные в ходе логического вывода конструкции.}
        \scnrelfrom{описание примера}{\scnfileimage[35em]{images/direct_inference_output.png}}
    \end{scnindent}
    \scntext{примечание}{Работа агента заключается в последовательном применении правил из входного множества правил,
        генерируя структуры, если атомарная формула принадлежит классу формул для генерации (\scnkeyword{concept\_formula\_for\_generation}).
        Если правило применилось безуспешно, то оно добавляется во множество безуспешно применённых
        правил, которые применяются повторно в случае успешного применения какого-либо другого правила. Также после
        каждого успешного применения правила проверяется, достигнута ли цель (если она передана), и, если цель достигнута,
        выполнение агента завершается успешно и остальные правила не применяются.}
    \begin{scnrelfromvector}{обобщённый алгоритм}
        \scnfileitem{Получение параметров агента, вызов агента;}
        \scnfileitem{Получение всех sc-узлов из arguments, если множество валидно, заполнение ими списка аргументов;}
        \scnfileitem{Проверка, достигнута ли уже цель в базе знаний с полученными аргументами;}
        \begin{scnindent}
            \scntext{примечание}{Выполняется поиск по шаблону target template с параметрами arguments.
            Если шаблон найден, агент завершает работу, возвращает узел, принадлежащий \scnkeyword{concept\_success\_solution}.}
        \end{scnindent}
        \scnfileitem{Построение вектора очереди формул на основе множества формул. Цикл по всем правилам и пока не достигнута цель;}
        \begin{scnindent}
            \begin{scnrelfromvector}{циклические операции}
                \scnfileitem{Получение посылки логической формулы;}
                \scnfileitem{Определение типа посылки (связка конъюнкции, дизъюнкции, отрицания или атомарная логическая формула);}
                \scnfileitem{Проверка истинности посылки в зависимости от её типа;}
                \begin{scnindent}
                    \scntext{замечание}{Конъюнкция, дизъюнкция, отрицание работают нестабильно.}
                \end{scnindent}
                \scnfileitem{Генерация по шаблону следствия;}
                \scnfileitem{Добавление в дерево решений узла формулы.}
                \begin{scnindent}
                    \scntext{примечание}{Смотрите пример ответа агента.}
                \end{scnindent}
            \end{scnrelfromvector}
        \end{scnindent}
        \scnfileitem{Формирование дерева применённых формул.}
    \end{scnrelfromvector}
\end{scnindent}

\begin{scnrelfromset}{недостатки текущего состояния}
    \scnfileitem{В текущем состоянии не реализован механизм применения правил вывода, вместо него указываются формулы
    для генерации, используя класс \scnkeyword{concept\_formula\_for\_generation}.}
    \scnfileitem{Генерируются только атомарные формулы.}
    \scnfileitem{Логическая связка отрицания некорректно работает с подстановками.}
    \scnfileitem{В структуру ответа агента входит только узел solution, а не вся структура решения.}
    \scnfileitem{Не реализована логика для входной структуры, поиск осуществляется по всей базе знаний.}
\end{scnrelfromset}

\begin{scnrelfromset}{преимущества текущего состояния}
    \scnfileitem{Агент работает корректно при передаче параметров в соответствии с предыдущим вариантом его реализации.}
    \scnfileitem{Проверка входных параметров не только по невалидности sc-узла, но и проверка на непустое множество.}
\end{scnrelfromset}
